-- DAY10

-- DDL
-- 테이블 무결성 제약조건 (CONSTRAINT)
--  CASCADE  함께 지운다

-- 1. NOT NULL
-- 컬럼에 값이 반드시 기록되어야 할 때 설정함 (웹에서의 필수입력항목을 뜻함)
-- 컬럼 레벨에서만 설정할 수 있음.

CREATE TABLE TESTNN (
    NNID NUMBER(5) NOT NULL,  -- 컬럼 레벨
    NN_NAME VARCHAR2(20)
);

-- 값 기록 테스트
INSERT INTO TESTNN (NNID, NN_NAME)
VALUES (NULL, NULL);  --ERROR
-- NNID 에 NOT NULL 제약조건 위배됨.

INSERT INTO TESTNN  -- 컬럼명이 생략되면, 테이블의 모든 컬럼에 값 기록해야 함
VALUES (1, NULL);  -- 테이블의 컬럼 생성 순서와 자료형 맞춰서 값 기록 나열함

SELECT * FROM TESTNN;

INSERT INTO TESTNN (NN_NAME)
VALUES ('ORACLE'); -- 생략된 컬럼은 자동 NULL 처리됨

INSERT INTO TESTNN (NNID)
VALUES (2);

-- 테이블 레벨 적용
CREATE TABLE TESTNN2 (
    NN_ID NUMBER(5) CONSTRAINT T2_NNID NOT NULL,
    NN_NAME VARCHAR2(10)--,
    -- 테이블 레벨
    -- [CONSTRAINT 제약조건이름] 제약조건종류 (적용할 컬럼명)
   -- CONSTRAINT T2_NNNAME NOT NULL (NN_NAME)   >> ERROR
);

-- 2. UNIQUE
-- 해당 컬럼의 중복값(같은값) 입력을 막겠다는 의미의 제약조건임
-- 설정하면 같은 값은 두번 기록 못 하는 컬럼이 됨
-- 컬럼레벨, 테이블레벨 둘 다 설정할 수 있음
-- 복합키로도 설정할 수 있음.

CREATE TABLE TESTUN (
    UN_ID CHAR(3) UNIQUE,
    UN_NAME VARCHAR2(10) NOT NULL
);

-- 기록 테스트
INSERT INTO TESTUN VALUES ('AAA', 'ORACLE');
INSERT INTO TESTUN VALUES ('AAA', 'JAVA');  -- 제약조건 위배됨 >> 에러
INSERT INTO TESTUN VALUES ('AAB', 'JAVA');

SELECT * FROM TESTUN;

CREATE TABLE TESTUN2 (
    UN_ID CHAR(3) CONSTRAINT T2_UNID UNIQUE,
    UN_NAME VARCHAR2(10) CONSTRAINT T2_UNNAME NOT NULL
);

CREATE TABLE TESTUN3 (
    UN_ID CHAR(3),
    UN_NAME VARCHAR2(10) NOT NULL,
    CONSTRAINT T3_UNID UNIQUE (UN_ID)
);

-- 3. PRIMARY KEY
-- 테이블에서 한 행의 정보를 찾기위해 쓸 수 있는 값이 기록된 컬럼에 적용함.
-- NUT NULL + UNIQUE
-- 한 테이블에 한 번만 사용할 수 있음.

CREATE TABLE TESTPK (
    PK_ID NUMBER PRIMARY KEY,
    PK_NAME VARCHAR2(15) NOT NULL,
    PK_DATE DATE
);

--기록 테스트
INSERT INTO TESTPK VALUES (1, '홍길동', '15/03/12');
INSERT INTO TESTPK VALUES (NULL, '박문수', SYSDATE); --ERROR : NOT NULL 제약조건 위배
INSERT INTO TESTPK VALUES (1, '박문수', SYSDATE); --ERROR : UNIQUE 제약조건 위배
INSERT INTO TESTPK VALUES (2, '박문수', SYSDATE);

SELECT * FROM TESTPK;

-- 테이블당 한 번만 설정할 수 있음
CREATE TABLE TESTPK2 (
    PK_ID NUMBER PRIMARY KEY,
    PK_NAME VARCHAR2(15) PRIMARY KEY
);  -- ERROR

-- 컬럼레벨에서 설정
CREATE TABLE TESTPK3 (
    PID NUMBER CONSTRAINT P2_PID PRIMARY KEY,
    PNAME VARCHAR2(15),
    PDATE DATE
);

-- 테이블레벨에서 설정
CREATE TABLE TESTPK4 (
    PID NUMBER,
    PNAME VARCHAR2(15),
    PDATE DATE,
    CONSTRAINT T3_PID PRIMARY KEY (PID)
);

-- 4. CHECK
-- 컬럼에 기록되는 값에 대한 조건 설정을 하는 제약조건임.
-- CHECK (컬럼명 연산자 비교값)
-- 비교값은 고정값이어야 함. 바뀌는 값이면 에러남.

CREATE TABLE TESTCHK (
    C_NAME VARCHAR2(15) CONSTRAINT TCK_NAME NOT NULL,
    C_PRICE NUMBER(5) CHECK (C_PRICE BETWEEN 1 AND 99999),
    C_LEVEL CHAR(1) CHECK (C_LEVEL IN ('A', 'B', 'C'))
);

INSERT INTO TESTCHK VALUES ('갤럭시 S9', 25000, 'A');
INSERT INTO TESTCHK VALUES ('LG G7', 125000, 'A'); -- ERROR : CHECK 제약조건 위배됨
INSERT INTO TESTCHK VALUES ('LG G7', 0, 'A'); --ERROR : CHECK 제약조건 위배됨.
INSERT INTO TESTCHK VALUES ('LG G7', 25134, 'D'); --ERROR : CHECK 제약조건 위배됨.

SELECT * FROM TESTCHK;

CREATE TABLE TESTCHK2 (
    C_NAME VARCHAR2(15) PRIMARY KEY,
    C_PRICE NUMBER(5) CHECK (C_PRICE >= 1 AND C_PRICE <= 99999),
    C_LEVEL CHAR(1) CHECK (C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
    --C_DATE DATE CHECK (C_DATE < SYSDATE) : ERROR
    -- 비교값은 반드시 리터럴(값) 사용, 바뀌는 값은 사용 못 함
    --C_DATE DATE CHECK (C_DATE < TO_DATE('16/01/01', 'RR/MM/DD'))  --OK
    C_DATE DATE CHECK (C_DATE < TO_DATE('16/01/01', 'YYYY/MM/DD')) -- BUG
);

-- 5. FOREIGN KEY
-- 외래키, 외부키
-- 다른 테이블에서 제공하는 값만 사용할 수 있는 컬럼을 의미함
-- 제공되지 않는 값 사용하면 에러남

-- 컬럼레벨에서 설정
-- [CONSTRAINT 이름] REFEPENCES 참조테이블명 [(참조할 컬럼명)]

-- 테이블레벨에서 설정
-- [CONSTRAINT 이름] FOREIGN KEY (적용할 컬럼명) REFEPENCES 참조테이블명 [(참조할 컬럼명)]
-- NULL 은 사용할 수 있음

CREATE TABLE TESTFK (
    EMP_ID CHAR(3) REFERENCES EMPLOYEE,
    -- 참조컬럼명이 생략되면 PRIMARY KEY 컬럼이 자동 연결됨
    DEPT_ID CHAR(2) CONSTRAINT TFK_DID REFERENCES DEPARTMENT (DEPT_ID),
    JOB_ID CHAR(2),
    -- 테이블레벨
    CONSTRAINT TFK_JID FOREIGN KEY (JOB_ID) REFERENCES JOB (JOB_ID)
);

-- 기록 테스트
-- 연결된 테이블의 연결된 컬럼에 기록되어 있는 값만 사용할 수 있음.
INSERT INTO TESTFK VALUES ('300', NULL, NULL); -- 제공되지 않는 값 사용, 에러
INSERT INTO TESTFK VALUES ('100', NULL, NULL); -- OK
INSERT INTO TESTFK VALUES ('200', '70', NULL); -- 제공되지 않는 부서코드 사용, 에러
INSERT INTO TESTFK VALUES ('200', '90', NULL); -- OK
INSERT INTO TESTFK VALUES ('124', '80', 'J9'); -- 제공되지 않는 직급코드 사용, 에러
INSERT INTO TESTFK VALUES ('124', '80', 'J7'); -- OK

SELECT * FROM TESTFK;

-- 외래키 제약조건에서 PARENT KEY 가 될 수 있는 컬럼은
-- PRIMARY KEY 또는 UNIQUE 제약조건이 설정된 컬럼만 참조컬럼이 될 수 있음
CREATE TABLE NOPK (
    ID CHAR(3),
    NAME VARCHAR2(10) 
);

CREATE TABLE TESTFK2 (
    FID CHAR(3) REFERENCES NOPK (ID),  --ERROR
    FNAME VARCHAR2(10)
);

CREATE TABLE TESTUN5 (
    ID CHAR(3) UNIQUE,
    NAME VARCHAR2(10)
);

CREATE TABLE TESTFK2 (
    FID CHAR(3) REFERENCES TESTUN5 (ID),
    FNAME VARCHAR2(10)
);

-- 복합키 설정 관련
-- 여러 개의 컬럼을 묶어서 UNIQUE 제약조건이나 PRIMARY KEY 제약조건을
-- 설정한 복합키를 참조할 경우
CREATE TABLE TEST_COMPLEX (
    ID NUMBER,
    NAME VARCHAR2(10),
    UNIQUE (ID, NAME)
);

INSERT INTO TEST_COMPLEX VALUES (100, 'ORACLE');
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES (100, NULL);
INSERT INTO TEST_COMPLEX VALUES (100, 'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES (NULL,'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL,'JAVA'); -- ERROR
INSERT INTO TEST_COMPLEX VALUES (100, 'JAVA'); -- ERROR

SELECT * FROM TEST_COMPLEX;

-- 복합키를 참조키로 설정할 경우
CREATE TABLE TESTFK4 (
    ID NUMBER,
    NAME VARCHAR2(10),
    PRICE NUMBER,
    FOREIGN KEY (ID,NAME) REFERENCES TEST_COMPLEX (ID,NAME)
);

-- 복합키로 설정된 참조컬럼은 따로 외래키 설정을 할 수 없음 : 에러
CREATE TABLE TESTFK4 (
    ID NUMBER REFERENCES TEST_COMPLEX (ID),
    NAME VARCHAR2(10) REFERENCES TEST_COMPLEX (NAME),
    PRICE NUMBER  
    --FOREIGN KEY (ID) REFERENCES TEST_COMPLEX (ID)
);  -- ERROR

-- 외래키가 설정된 컬럼에 값이 사용 중이면, 부모키는 절대 삭제할 수 없음.
DELETE FROM DEPARTMENT 
WHERE DEPT_ID = '90'; -- 삭제 못 함
-- EMPLOYEE 테이블에 DEPT_ID 컬럼에 '90'이 사용되고 있음 : CHILD RECORD

-- FOREIGN KEY 제약조건 설정시 삭제옵션을 추가할 수 있음 : DELETION OPTION 
-- 기본은 자식레코드가 존재하면 부모키는 삭제 불가능임 (RESTRICTED)
-- ON DELETE SET NULL, ON DELETE CASCADE

-- ON DELETE SET NULL
-- 부모키가 삭제될 때 자식 레코드 값을 NULL 로 바꿈
CREATE  TABLE PRODUCT_STATE (
    PSTATE CHAR(1) PRIMARY KEY,
    PCOMMENT VARCHAR2(10)
);

INSERT INTO PRODUCT_STATE VALUES ('A', '최고급');
INSERT INTO PRODUCT_STATE VALUES ('B', '보통');
INSERT INTO PRODUCT_STATE VALUES ('C', '저급');

SELECT * FROM PRODUCT_STATE;

CREATE TABLE PRODUCT (
    PNAME VARCHAR2(20) PRIMARY KEY,
    PPRICE NUMBER CHECK (PPRICE > 0),
    PSTATE CHAR(1) REFERENCES PRODUCT_STATE ON DELETE SET NULL
);

INSERT INTO PRODUCT VALUES ('갤럭시', 50202, 'A');
INSERT INTO PRODUCT VALUES ('G7', 255330, 'B');
INSERT INTO PRODUCT VALUES ('맥북', 1222200, 'C');

SELECT * FROM PRODUCT;

-- 삭제 테스트
DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'A';

COMMIT; --DML은 커밋을 꼭 해줘야 저장함.

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_STATE;

-- ON DELETE CASCADE
-- 제공되는 부모키가 삭제되면, 제공값을 사용하는 자식 레코드도 함께 삭제됨
CREATE TABLE PRODUCT2 (
    PNAME VARCHAR2(20) PRIMARY KEY,
    PPRICE NUMBER,
    PSTATE CHAR(1) REFERENCES PRODUCT_STATE (PSTATE) ON DELETE CASCADE
);

INSERT INTO PRODUCT2 VALUES ('맥북', 222222222, 'B');
INSERT INTO PRODUCT2 VALUES ('맥에어', 33333333, 'C');

SELECT * FROM PRODUCT2;

-- 부모키 삭제
DELETE FROM PRODUCT_STATE 
WHERE PSTATE = 'B';

COMMIT;

-- 같이 삭제된 것 확인
SELECT * FROM PRODUCT_STATE;
SELECT * FROM PRODUCT2;

--SAMPLE SCRIPT
CREATE TABLE CONSTRAINT_EMP (
    EID CHAR(3) CONSTRAINT PKEID PRIMARY KEY,
    ENAME VARCHAR2(20) CONSTRAINT NENAME NOT NULL,
    ENO CHAR(14) CONSTRAINT NENO NOT NULL CONSTRAINT UENO UNIQUE,
    EMAIL VARCHAR2(25) CONSTRAINT UEMAIL UNIQUE,
    PHONE VARCHAR2(12),
    HIRE_DATE DATE DEFAULT SYSDATE,
    JID CHAR(2) CONSTRAINT FKJID REFERENCES JOB ON DELETE SET NULL,
    SALARY NUMBER,
    BONUS_PCT NUMBER,
    MARRIAGE CHAR(1) DEFAULT 'N' CONSTRAINT CHK CHECK (MARRIAGE IN ('Y', 'N')),
    MID CHAR(3) CONSTRAINT FKMID REFERENCES CONSTRAINT_EMP ON DELETE SET NULL,
    DID CHAR(2),
    CONSTRAINT FKDID FOREIGN KEY (DID) REFERENCES DEPARTMENT ON DELETE CASCADE
);

CREATE TABLE TABLE_SUBQUERY1
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
    FROM EMPLOYEE
    LEFT JOIN DEPARTMENT USING (DEPT_ID)
    LEFT JOIN JOB USING (JOB_ID);

SELECT * FROM TABLE_SUBQUERY1;

-- DESCRIBE 테이블명;
-- DESC 테이블명;
-- 테이블의 구조를 확인하는 명령어
DESCRIBE TABLE_SUBQUERY1;
DESC TABLE_SUBQUERY1;

-- 직원 테이블에서 90번 부서에 소속된 직원 정보만 따로 EMP_COPY90 테이블에 저장
CREATE TABLE EMP_COPY90
AS SELECT *
    FROM EMPLOYEE
    WHERE DEPT_ID = '90';
    
SELECT * FROM EMP_COPY90;
DESC EMP_COPY90;

-- 복사본 테이블 만들기
CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;

DESC EMP_COPY;
-- 서브쿼리를 이용해서 기존테이블을 복사할 경우,
-- 컬럼명, 자료형, NOT NULL 제약조건, 값은 그대로 복사됨.
-- 나머지 제약조건들은 복사되지 않음.

-- 제약조건 관련 데이터딕셔너리 확인
-- USER_CONSTRAINTS
SELECT * FROM USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_COPY';

-- 실습 1
-- 사번, 이름, 급여, 직급명, 부서명, 근무지역명, 소속국가명 조회
-- 조회 결과를 EMP_LIST 테이블에 저장함
CREATE TABLE EMP_LIST
AS 
SELECT EMP_ID, EMP_NAME, JOB_TITLE, DEPT_NAME, 
          LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN LOCATION ON (LOC_ID = LOCATION_ID)
LEFT JOIN COUNTRY USING (COUNTRY_ID);

SELECT * FROM EMP_LIST;

-- 실습 2
-- EMPLOYEE 테이블에서 남자 직원의 정보만 조회해서
-- EMP_MAN 테이블에 저장함
CREATE TABLE EMP_MAN 
AS SELECT *
    FROM EMPLOYEE
    WHERE EMP_NO LIKE '_______1%';
    
SELECT * FROM EMP_MAN;    

-- 실습 3
-- 여자 직원의 정보만 조회해서, EMP_FEMAIL 테이블에 저장함.

CREATE TABLE EMP_FEMAIL
AS SELECT *
     FROM EMPLOYEE
     WHERE EMP_NO LIKE '_______2%';
     
SELECT * FROM EMP_FEMAIL;     

-- 실습 4
-- 부서별 직원 명단을 정리해서 PART_LIST 테이블에 저장함
-- DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID 로 컬럼 구성함
-- 컬럼에 주석 달기 : 부서명, 직급명, 사원명, 사번
CREATE TABLE PART_LIST
AS SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
    FROM EMPLOYEE
    LEFT JOIN JOB USING (JOB_ID)
    LEFT JOIN DEPARTMENT USING (DEPT_ID)
    ORDER BY DEPT_NAME;

COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
COMMENT ON COLUMN PART_LIST.EMP_NAME IS '사원명';
COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번';

SELECT * FROM PART_LIST;

DROP TABLE PART_LIST;

-- 실습 : 제약조건이 설정된 테이블 만들기
-- 테이블명 : PHONEBOOK
-- 컬럼명 :  ID  CHAR(3) 기본키(저장이름 : PK_PBID)
--         PNAME      VARCHAR2(20)  널 사용못함.
--                                 (NN_PBNAME) 
--         PHONE      VARCHAR2(15)  널 사용못함
--                                 (NN_PBPHONE)
--                                 중복값 입력못함
--                                 (UN_PBPHONE)
--         ADDRESS    VARCHAR2(100) 기본값 지정함
--                                 '서울시 구로구'

-- NOT NULL을 제외하고, 모두 테이블 레벨에서 지정함
CREATE TABLE PHONEBOOK (
    ID CHAR(3),
    PNAME VARCHAR2(20) CONSTRAINT NN_PBNAME NOT NULL,
    PHONE VARCHAR2(15) CONSTRAINT NN_PBPHONE NOT NULL, 
    ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구',
    CONSTRAINT PK_PBID PRIMARY KEY (ID),
    CONSTRAINT UN_PBPHONE UNIQUE (PHONE)
);

INSERT INTO PHONEBOOK VALUES ('A10','홍길동', '010-3522-2522', '서울시 강남구');
INSERT INTO PHONEBOOK VALUES ('A11','홍난기', '010-777-7777', DEFAULT);

SELECT * FROM PHONEBOOK;